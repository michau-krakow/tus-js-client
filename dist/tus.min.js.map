{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/browser/base64.js","lib/browser/request.js","lib/browser/source.js","lib/browser/storage.js","lib/error.js","lib/fingerprint.js","lib/index.js","lib/upload.js","node_modules/extend/index.js","node_modules/querystringify/index.js","node_modules/requires-port/index.js","node_modules/url-parse/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","tus","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_dereq_","encode","btoa","data","unescape","encodeURIComponent","isSupported","newRequest","resolveUrl","_urlParse","XMLHttpRequest","origin","link","_urlParse2","default","toString","getSource","FileSource","file","_classCallCheck","_file","size","start","end","slice","input","setItem","getItem","removeItem","hasStorage","key","localStorage","SECURITY_ERR","QUOTA_EXCEEDED_ERR","canStoreURLs","value","DetailedError","error","causingErr","arguments","undefined","xhr","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","message","originalRequest","causingError","status","responseText","fingerprint","options","name","type","lastModified","endpoint","join","_upload","_storage","defaultOptions","_upload2","_window","Blob","prototype","Upload","_fingerprint","_error","_extend","_request","_source","_base","Base64","Storage","_fingerprint2","resume","onProgress","onChunkComplete","onSuccess","onError","headers","chunkSize","Infinity","withCredentials","uploadUrl","uploadSize","agent","overridePatchMethod","retryDelays","removeFingerprintOnSuccess","_extend2","url","_xhr","_offset","_aborted","_size","_retryAttempt","_retryTimeout","_offsetBeforeRetry","_emitError","source","isNaN","errorCallback","err","shouldResetDelays","isOnline","navigator","onLine","shouldRetry","inStatusCategory","delay","setTimeout","_resumeUpload","resumedUrl","_createUpload","abort","close","clearTimeout","_error2","bytesSent","bytesTotal","bytesAccepted","setRequestHeader","_this2","open","onload","_emitXhrError","location","getResponseHeader","_emitSuccess","_startUpload","onerror","_setupXHR","metadata","encodeMetadata","send","_this3","offset","parseInt","_emitProgress","_this4","setAgent","_emitChunkComplete","upload","onprogress","lengthComputable","loaded","encoded","push","category","hasOwn","hasOwnProperty","toStr","defineProperty","gOPD","getOwnPropertyDescriptor","isArray","arr","Array","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","target","enumerable","configurable","newValue","writable","getProperty","extend","src","copy","copyIsArray","clone","deep","has","decode","decodeURIComponent","replace","querystring","query","parser","result","part","exec","querystringify","prefix","pairs","stringify","parse","required","port","protocol","split","qs","protocolre","slashes","rules","sanitize","address","NaN","ignore","hash","lolcation","loc","finaldestination","Url","pathname","test","href","extractProtocol","match","toLowerCase","rest","resolve","relative","base","path","concat","last","unshift","up","splice","extracted","instruction","index","instructions","indexOf","charAt","host","hostname","username","password","auth","set","fn","pop","char","ins"],"mappings":"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","file":"./dist/tus.min.js","sourceRoot":"","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/* global: window */\n\nconst {btoa} = window;\n\nexport function encode(data) {\n  return btoa(unescape(encodeURIComponent(data)));\n}\n\nexport const isSupported = \"btoa\" in window;\n","/* global window */\nimport URL from \"url-parse\";\n\nexport function newRequest() {\n  return new window.XMLHttpRequest();\n}\n\nexport function resolveUrl(origin, link) {\n  return new URL(link, origin).toString();\n}\n","class FileSource {\n  constructor(file) {\n    this._file = file;\n    this.size = file.size;\n  }\n\n  slice(start, end) {\n    return this._file.slice(start, end);\n  }\n\n  close() {}\n}\n\nexport function getSource(input) {\n  // Since we emulate the Blob type in our tests (not all target browsers\n  // support it), we cannot use `instanceof` for testing whether the input value\n  // can be handled. Instead, we simply check is the slice() function and the\n  // size property are available.\n  if (typeof input.slice === \"function\" && typeof input.size !== \"undefined\") {\n    return new FileSource(input);\n  }\n\n  throw new Error(\"source object may only be an instance of File or Blob in this environment\");\n}\n","/* global window, localStorage */\n\nlet hasStorage = false;\ntry {\n  hasStorage = \"localStorage\" in window;\n\n  // Attempt to store and read entries from the local storage to detect Private\n  // Mode on Safari on iOS (see #49)\n  var key = \"tusSupport\";\n  localStorage.setItem(key, localStorage.getItem(key));\n\n} catch (e) {\n  // If we try to access localStorage inside a sandboxed iframe, a SecurityError\n  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is\n  // thrown (see #49)\n  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {\n    hasStorage = false;\n  } else {\n    throw e;\n  }\n}\n\nexport const canStoreURLs = hasStorage;\n\nexport function setItem(key, value) {\n  if (!hasStorage) return;\n  return localStorage.setItem(key, value);\n}\n\nexport function getItem(key) {\n  if (!hasStorage) return;\n  return localStorage.getItem(key);\n}\n\nexport function removeItem(key) {\n  if (!hasStorage) return;\n  return localStorage.removeItem(key);\n}\n","class DetailedError extends Error {\n  constructor(error, causingErr = null, xhr = null) {\n    super(error.message);\n\n    this.originalRequest = xhr;\n    this.causingError = causingErr;\n\n    let message = error.message;\n    if (causingErr != null) {\n      message += `, caused by ${causingErr.toString()}`;\n    }\n    if (xhr != null) {\n      message += `, originated from request (response code: ${xhr.status}, response text: ${xhr.responseText})`;\n    }\n    this.message = message;\n  }\n}\n\nexport default DetailedError;\n","/**\n * Generate a fingerprint for a file which will be used the store the endpoint\n *\n * @param {File} file\n * @return {String}\n */\nexport default function fingerprint(file, options) {\n  return [\n    \"tus\",\n    file.name,\n    file.type,\n    file.size,\n    file.lastModified,\n    options.endpoint\n  ].join(\"-\");\n}\n","/* global window */\nimport Upload from \"./upload\";\nimport {canStoreURLs} from \"./node/storage\";\n\nconst {defaultOptions} = Upload;\nlet isSupported;\n\nif (typeof window !== \"undefined\") {\n  // Browser environment using XMLHttpRequest\n  const {XMLHttpRequest, Blob} = window;\n\n  isSupported = (\n    XMLHttpRequest &&\n    Blob &&\n    typeof Blob.prototype.slice === \"function\"\n  );\n} else {\n  // Node.js environment using http module\n  isSupported = true;\n}\n\n// The usage of the commonjs exporting syntax instead of the new ECMAScript\n// one is actually inteded and prevents weird behaviour if we are trying to\n// import this module in another module using Babel.\nmodule.exports = {\n  Upload,\n  isSupported,\n  canStoreURLs,\n  defaultOptions\n};\n","/* global window */\nimport fingerprint from \"./fingerprint\";\nimport DetailedError from \"./error\";\nimport extend from \"extend\";\n\n// We import the files used inside the Node environment which are rewritten\n// for browsers using the rules defined in the package.json\nimport {newRequest, resolveUrl} from \"./node/request\";\nimport {getSource} from \"./node/source\";\nimport * as Base64 from \"./node/base64\";\nimport * as Storage from \"./node/storage\";\n\nconst defaultOptions = {\n  endpoint: null,\n  fingerprint,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null,\n  agent: null,\n  overridePatchMethod: false,\n  retryDelays: null,\n  removeFingerprintOnSuccess: false\n};\n\nclass Upload {\n  constructor(file, options) {\n    this.options = extend(true, {}, defaultOptions, options);\n\n    // The underlying File/Blob object\n    this.file = file;\n\n    // The URL against which the file will be uploaded\n    this.url = null;\n\n    // The underlying XHR object for the current PATCH request\n    this._xhr = null;\n\n    // The fingerpinrt for the current file (set after start())\n    this._fingerprint = null;\n\n    // The offset used in the current PATCH request\n    this._offset = null;\n\n    // True if the current PATCH request has been aborted\n    this._aborted = false;\n\n    // The file's size in bytes\n    this._size = null;\n\n    // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n    this._source = null;\n\n    // The current count of attempts which have been made. Null indicates none.\n    this._retryAttempt = 0;\n\n    // The timeout's ID which is used to delay the next retry\n    this._retryTimeout = null;\n\n    // The offset of the remote upload before the latest attempt was started.\n    this._offsetBeforeRetry = 0;\n  }\n\n  start() {\n    let file = this.file;\n\n    if (!file) {\n      this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n      return;\n    }\n\n    if (!this.options.endpoint && !this.options.uploadUrl) {\n      this._emitError(new Error(\"tus: neither an endpoint or an upload URL is provided\"));\n      return;\n    }\n\n    let source = this._source = getSource(file, this.options.chunkSize);\n\n    // Firstly, check if the caller has supplied a manual upload size or else\n    // we will use the calculated size by the source object.\n    if (this.options.uploadSize != null) {\n      let size = +this.options.uploadSize;\n      if (isNaN(size)) {\n        throw new Error(\"tus: cannot convert `uploadSize` option into a number\");\n      }\n\n      this._size = size;\n    } else {\n      let size = source.size;\n\n      // The size property will be null if we cannot calculate the file's size,\n      // for example if you handle a stream.\n      if (size == null) {\n        throw new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\");\n      }\n\n      this._size = size;\n    }\n\n    let retryDelays = this.options.retryDelays;\n    if (retryDelays != null) {\n      if (Object.prototype.toString.call(retryDelays) !== \"[object Array]\") {\n        throw new Error(\"tus: the `retryDelays` option must either be an array or null\");\n      } else {\n        let errorCallback = this.options.onError;\n        this.options.onError = (err) => {\n          // Restore the original error callback which may have been set.\n          this.options.onError = errorCallback;\n\n          // We will reset the attempt counter if\n          // - we were already able to connect to the server (offset != null) and\n          // - we were able to upload a small chunk of data to the server\n          let shouldResetDelays = this._offset != null && (this._offset > this._offsetBeforeRetry);\n          if (shouldResetDelays) {\n            this._retryAttempt = 0;\n          }\n\n          let isOnline = true;\n          if (typeof window !== \"undefined\" &&\n             \"navigator\" in window &&\n             window.navigator.onLine === false) {\n               isOnline = false;\n             }\n\n          // We only attempt a retry if\n          // - we didn't exceed the maxium number of retries, yet, and\n          // - this error was caused by a request or it's response and\n          // - the error is not a client error (status 4xx) and\n          // - the browser does not indicate that we are offline\n          let shouldRetry = this._retryAttempt < retryDelays.length &&\n                            err.originalRequest != null &&\n                            !inStatusCategory(err.originalRequest.status, 400) &&\n                            isOnline;\n\n          if (!shouldRetry) {\n            this._emitError(err);\n            return;\n          }\n\n          let delay = retryDelays[this._retryAttempt++];\n\n          this._offsetBeforeRetry = this._offset;\n          this.options.uploadUrl = this.url;\n\n          this._retryTimeout = setTimeout(() => {\n            this.start();\n          }, delay);\n        };\n      }\n    }\n\n    // Reset the aborted flag when the upload is started or else the\n    // _startUpload will stop before sending a request if the upload has been\n    // aborted previously.\n    this._aborted = false;\n\n    // The upload had been started previously and we should reuse this URL.\n    if (this.url != null) {\n      this._resumeUpload();\n      return;\n    }\n\n    // A URL has manually been specified, so we try to resume\n    if (this.options.uploadUrl != null) {\n        this.url = this.options.uploadUrl;\n        this._resumeUpload();\n        return;\n    }\n\n    // Try to find the endpoint for the file in the storage\n    if (this.options.resume) {\n        this._fingerprint = this.options.fingerprint(file, this.options);\n        let resumedUrl = Storage.getItem(this._fingerprint);\n\n        if (resumedUrl != null) {\n            this.url = resumedUrl;\n            this._resumeUpload();\n            return;\n        }\n    }\n\n    // An upload has not started for the file yet, so we start a new one\n    this._createUpload();\n  }\n\n  abort() {\n    if (this._xhr !== null) {\n      this._xhr.abort();\n      this._source.close();\n      this._aborted = true;\n    }\n\n    if (this._retryTimeout != null) {\n      clearTimeout(this._retryTimeout);\n      this._retryTimeout = null;\n    }\n  }\n\n  _emitXhrError(xhr, err, causingErr) {\n    this._emitError(new DetailedError(err, causingErr, xhr));\n  }\n\n  _emitError(err) {\n    if (typeof this.options.onError === \"function\") {\n      this.options.onError(err);\n    } else {\n      throw err;\n    }\n  }\n\n  _emitSuccess() {\n    if (typeof this.options.onSuccess === \"function\") {\n      this.options.onSuccess();\n    }\n  }\n\n  /**\n   * Publishes notification when data has been sent to the server. This\n   * data may not have been accepted by the server yet.\n   * @param  {number} bytesSent  Number of bytes sent to the server.\n   * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n   */\n  _emitProgress(bytesSent, bytesTotal) {\n    if (typeof this.options.onProgress === \"function\") {\n      this.options.onProgress(bytesSent, bytesTotal);\n    }\n  }\n\n  /**\n   * Publishes notification when a chunk of data has been sent to the server\n   * and accepted by the server.\n   * @param  {number} chunkSize  Size of the chunk that was accepted by the\n   *                             server.\n   * @param  {number} bytesAccepted Total number of bytes that have been\n   *                                accepted by the server.\n   * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n   */\n  _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n    if (typeof this.options.onChunkComplete === \"function\") {\n      this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n    }\n  }\n\n  /**\n   * Set the headers used in the request and the withCredentials property\n   * as defined in the options\n   *\n   * @param {XMLHttpRequest} xhr\n   */\n  _setupXHR(xhr) {\n    this._xhr = xhr;\n\n    xhr.setRequestHeader(\"Tus-Resumable\", \"1.0.0\");\n    let headers = this.options.headers;\n\n    for (let name in headers) {\n      xhr.setRequestHeader(name, headers[name]);\n    }\n\n    xhr.withCredentials = this.options.withCredentials;\n  }\n\n  /**\n   * Create a new upload using the creation extension by sending a POST\n   * request to the endpoint. After successful creation the file will be\n   * uploaded\n   *\n   * @api private\n   */\n  _createUpload() {\n    if (!this.options.endpoint) {\n      this._emitError(new Error(\"tus: unable to create upload because no endpoint is provided\"));\n      return;\n    }\n\n    let xhr = newRequest();\n    xhr.open(\"POST\", this.options.endpoint, true);\n\n    xhr.onload = () => {\n      if (!inStatusCategory(xhr.status, 200)) {\n        this._emitXhrError(xhr, new Error(\"tus: unexpected response while creating upload\"));\n        return;\n      }\n\n      let location = xhr.getResponseHeader(\"Location\");\n      if (location == null) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing Location header\"));\n        return;\n      }\n\n      this.url = resolveUrl(this.options.endpoint, location);\n\n      if (this._size === 0) {\n        // Nothing to upload and file was successfully created\n        this._emitSuccess();\n        this._source.close();\n        return;\n      }\n\n      if (this.options.resume) {\n        Storage.setItem(this._fingerprint, this.url);\n      }\n\n      this._offset = 0;\n      this._startUpload();\n    };\n\n    xhr.onerror = (err) => {\n      this._emitXhrError(xhr, new Error(\"tus: failed to create upload\"), err);\n    };\n\n    this._setupXHR(xhr);\n    xhr.setRequestHeader(\"Upload-Length\", this._size);\n\n    // Add metadata if values have been added\n    var metadata = encodeMetadata(this.options.metadata);\n    if (metadata !== \"\") {\n        xhr.setRequestHeader(\"Upload-Metadata\", metadata);\n    }\n\n    xhr.send(null);\n  }\n\n  /*\n   * Try to resume an existing upload. First a HEAD request will be sent\n   * to retrieve the offset. If the request fails a new upload will be\n   * created. In the case of a successful response the file will be uploaded.\n   *\n   * @api private\n   */\n  _resumeUpload() {\n    let xhr = newRequest();\n    xhr.open(\"HEAD\", this.url, true);\n\n    xhr.onload = () => {\n      if (!inStatusCategory(xhr.status, 200)) {\n        if (this.options.resume && inStatusCategory(xhr.status, 400)) {\n          // Remove stored fingerprint and corresponding endpoint,\n          // on client errors since the file can not be found\n          Storage.removeItem(this._fingerprint);\n        }\n\n        // If the upload is locked (indicated by the 423 Locked status code), we\n        // emit an error instead of directly starting a new upload. This way the\n        // retry logic can catch the error and will retry the upload. An upload\n        // is usually locked for a short period of time and will be available\n        // afterwards.\n        if (xhr.status === 423) {\n          this._emitXhrError(xhr, new Error(\"tus: upload is currently locked; retry later\"));\n          return;\n        }\n\n        if (!this.options.endpoint) {\n          // Don't attempt to create a new upload if no endpoint is provided.\n          this._emitXhrError(xhr, new Error(\"tus: unable to resume upload (new upload cannot be created without an endpoint)\"));\n          return;\n        }\n\n        // Try to create a new upload\n        this.url = null;\n        this._createUpload();\n        return;\n      }\n\n      let offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      let length = parseInt(xhr.getResponseHeader(\"Upload-Length\"), 10);\n      if (isNaN(length)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing length value\"));\n        return;\n      }\n\n      // Upload has already been completed and we do not need to send additional\n      // data to the server\n      if (offset === length) {\n        this._emitProgress(length, length);\n        this._emitSuccess();\n        return;\n      }\n\n      this._offset = offset;\n      this._startUpload();\n    };\n\n    xhr.onerror = (err) => {\n      this._emitXhrError(xhr, new Error(\"tus: failed to resume upload\"), err);\n    };\n\n    this._setupXHR(xhr);\n    xhr.send(null);\n  }\n\n  /**\n   * Start uploading the file using PATCH requests. The file will be divided\n   * into chunks as specified in the chunkSize option. During the upload\n   * the onProgress event handler may be invoked multiple times.\n   *\n   * @api private\n   */\n  _startUpload() {\n    // If the upload has been aborted, we will not send the next PATCH request.\n    // This is important if the abort method was called during a callback, such\n    // as onChunkComplete or onProgress.\n    if (this._aborted) {\n      return;\n    }\n\n    let xhr = newRequest();\n\n    if (this.options.agent) {\n      if (xhr.setAgent === undefined) {\n        this._emitXhrError(xhr, new Error(\"tus: can't use custom Agent in this environment\"));\n        return;\n      }\n\n      xhr.setAgent(this.options.agent);\n    }\n\n    // Some browser and servers may not support the PATCH method. For those\n    // cases, you can tell tus-js-client to use a POST request with the\n    // X-HTTP-Method-Override header for simulating a PATCH request.\n    if (this.options.overridePatchMethod) {\n      xhr.open(\"POST\", this.url, true);\n      xhr.setRequestHeader(\"X-HTTP-Method-Override\", \"PATCH\");\n    } else {\n      xhr.open(\"PATCH\", this.url, true);\n    }\n\n    xhr.onload = () => {\n      if (!inStatusCategory(xhr.status, 200)) {\n        this._emitXhrError(xhr, new Error(\"tus: unexpected response while uploading chunk\"));\n        return;\n      }\n\n      let offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        if (this.options.removeFingerprintOnSuccess && this.options.resume) {\n          // Remove stored fingerprint and corresponding endpoint. This causes\n          // new upload of the same file must be treated as a different file.\n          Storage.removeItem(this._fingerprint);\n        }\n\n        // Yay, finally done :)\n        this._emitSuccess();\n        this._source.close();\n        return;\n      }\n\n      this._startUpload();\n    };\n\n    xhr.onerror = (err) => {\n      // Don't emit an error if the upload was aborted manually\n      if (this._aborted) {\n        return;\n      }\n\n      this._emitXhrError(xhr, new Error(\"tus: failed to upload chunk at offset \" + this._offset), err);\n    };\n\n    // Test support for progress events before attaching an event listener\n    if (\"upload\" in xhr) {\n      xhr.upload.onprogress = (e) => {\n        if (!e.lengthComputable) {\n          return;\n        }\n\n        this._emitProgress(start + e.loaded, this._size);\n      };\n    }\n\n    this._setupXHR(xhr);\n\n    xhr.setRequestHeader(\"Upload-Offset\", this._offset);\n    xhr.setRequestHeader(\"Content-Type\", \"application/offset+octet-stream\");\n\n    let start = this._offset;\n    let end = this._offset + this.options.chunkSize;\n\n    // The specified chunkSize may be Infinity or the calcluated end position\n    // may exceed the file's size. In both cases, we limit the end position to\n    // the input's total size for simpler calculations and correctness.\n    if (end === Infinity || end > this._size) {\n      end = this._size;\n    }\n\n    xhr.send(this._source.slice(start, end));\n\n    // Emit an progress event when a new chunk begins being uploaded.\n    this._emitProgress(this._offset, this._size);\n  }\n}\n\nfunction encodeMetadata(metadata) {\n    if (!Base64.isSupported) {\n        return \"\";\n    }\n\n    var encoded = [];\n\n    for (var key in metadata) {\n        encoded.push(key + \" \" + Base64.encode(metadata[key]));\n    }\n\n    return encoded.join(\",\");\n}\n\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\nfunction inStatusCategory(status, category) {\n  return (status >= category && status < (category + 100));\n}\n\nUpload.defaultOptions = defaultOptions;\n\nexport default Upload;\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  return decodeURIComponent(input.replace(/\\+/g, ' '));\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    if (key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address) {          // Sanitize what is left of the address\n    return address.replace('\\\\', '/');\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var location = global && global.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address) {\n  var match = protocolre.exec(address);\n\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3]\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} location Location defaults for relative paths.\n * @param {Boolean|Function} parser Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '');\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.qs = qs;\n\nmodule.exports = Url;\n"]}